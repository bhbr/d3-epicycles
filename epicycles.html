<!DOCTYPE html>
<head>
    <meta charset='utf-8'>
    <script src='d3.v4.min.js'></script>
    <style>
        body {
            margin:0;position:fixed;top:0;right:0;bottom:0;left:0;
            font-family: 'Helvetica';
            font-size: 25px;
            background-color: grey;
        }
        input {
            font-family: 'Helvetica';
            font-size: 25px;
        }
        svg .planet {
            cursor: grab;
        }
        svg text {
            -webkit-user-select: none;
            -webkit-moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            font-size: 25px;
            font-family: 'Helvetica';
        }
        svg .planet-label {
            cursor: grab;
        }
        svg .incrementer {
            cursor: pointer;
        }
        svg text::selection {
            background: none;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            width: 100%;
            padding-bottom: 0%; /* aspect ratio */
            vertical-align: top;
            overflow: hidden;
            margin: auto;
        }
        .svg-content-responsive {
            display: inline-block;
            position: absolute;
            top: 0px;
            left: 0;
        }
        .button-div {
            display: inline-block;
            position: absolute;
            width: 100%;
            bottom: 25px;
        }

        .magnifier {
            position: absolute;
            top: 10px;
            left: 10px;
        }
    </style>
</head>

<body>
    <script>

        var body = d3.select('body');

        function linspace(xMin,xMax,n) {
            if (n < 1) {
                return [];
            } else if (n == 1) {
                return [(xMin + xMax)/2];
            }
            else {
                dx = (xMax - xMin)/(n-1);
                var returnArray = [xMin];
                for (var i = 1; i < n; i++) {
                    returnArray.push(xMin + i * dx);
                }
                return returnArray;
            }
        }

        function colorwheel(n) {
            var nbCopies = Math.ceil(n/5);
            var returnArray = [];
            for (var i = 0; i < nbCopies; i++) {
                returnArray = returnArray.concat([
                    'url(#gradient1)',
                    'url(#gradient2)',
                    'url(#gradient3)',
                    'url(#gradient4)',
                    'url(#gradient5)',
                ]);
            }
            return returnArray.slice(0,n);
        }


        function remove(obj) {
            if (obj != undefined) { obj.remove(); }
        }

        function insert(parent,obj) {
            parent.insert(function() { return obj.node(); });
        }

        function clone(obj) {
            return obj.clone(true);
        }


        function raise(obj) {
            if (obj != undefined) { obj.raise(); }
        }



        // GLOBAL VARIABLES //
        var TAU = 6.283185;
        
        var mainWidth = 1000;
        var mainHeight = 500;
        var magnifierWidth = 300;
        var magnifierHeight = 200;
        var originalMagnification = 1;
        var magnification = originalMagnification;

        var nbPlanets = 3;
        var globalPeriod = 12000;

        var bodyRadii, bodyColors, planetIDs, orbitalRadii, orbitalFrequencies, orbitalPeriods, orbitalPhases, shouldDrawTrace, shouldDrawOrbit, orbit, orbitToFit, upArrow, downArrow, venusImage, planets, planetLabels, epicycles, links, trace, traceToFit, traceArray, traceToFitArray, dragstartX, dragstartY, planetToFit, magnifiedOrbit, magnifiedOrbitToFit, mainFigure, backgroundRect, magnifier, magnifierFrame,selectedPlanet, upArrowBox, downArrowBox, magnifiedEpicycles, residualLabel;

        var shouldDrawOrbit = false;
        var shouldDrawTrace = true;
        var maxTraceSize = 50;

        var fontScale = 1.6;

        var traceSpacing = 2;
        var traceSpacingCounter = 0;
        var residualSpacing = traceSpacing;
        var residualSpacingCounter = 0;
        var radiusBufferRatio = 0.7;
        var opacityFactor = 0.005;

        // CREATING TIMER //
        var timestamp = 0;
        var addedTime = 0; // time shift incremented whenever stopping
        var trueT = 0;
        var timer = d3.timer(play)
             .stop();
        var shouldPlay = false;
        var shouldShowEpicycles = true;
        var shouldShowLinks = false;

        var dragHandler;
        var T = d3.zoomIdentity;

        function setupPlanetLooks(n) {
            bodyRadii = [20];
            for (var i = 0; i < 100; i++) {
                bodyRadii.push(0.75 * bodyRadii[bodyRadii.length - 1]);
            }
            bodyColors = colorwheel(100);
            planetIDs = [];
            for (var i = 0; i < 100; i++) {
                planetIDs.push(i);
            }
        }
        setupPlanetLooks(nbPlanets);

        // orbit radii and phases
        function setupOrbitalData(n) {
            
            orbitalRadii = linspace(200,40,nbPlanets);
            orbitalRadii[0] = 0;

            orbitalFrequencies = linspace(1, 3 * (nbPlanets - 1) + 1, nbPlanets);
            orbitalFrequencies.splice(0,0,0);
            orbitalPeriods = [];
            for (var i = 0; i < nbPlanets; i++) {
                orbitalPeriods.push(globalPeriod/orbitalFrequencies[i]);
            }
            orbitalPhases = [];
            for (var i = 0; i < nbPlanets; i++) {
                orbitalPhases.push(0); //Math.random() * TAU);
            }
        }
        setupOrbitalData(nbPlanets);

        // setting up the main window and magnifier inset
        function setupFigures() {       
            mainFigure = body.append('svg')
                .classed('svg-container', true)
                .classed('svg-content-responsive', true)
                .attr('preserveAspectRatio', 'xMinYMin slice')
                .attr('viewBox', '0 0 ' + mainWidth + ' ' + mainHeight)
                .call(d3.zoom().on('zoom', mainFigureZoom))
                .on('dblclick.zoom', null);

            backgroundRect = mainFigure.append('rect')
                .attr('x',0)
                .attr('y',0)
                .attr('width',mainWidth)
                .attr('height',mainHeight)
                .attr('fill','url(#gradient0)')
                .attr('opacity',1)
                .attr('stroke','none')
                .on('click', deselectPlanet);

            magnifier = body.append('svg')
                .classed('magnifier', true)
                .attr('width', magnifierWidth)
                .attr('height', magnifierHeight)
                .call(d3.zoom().on('zoom', magnifierZoom))
                .on('dblclick.zoom', null);

            magnifierFrame = magnifier.append('rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', magnifierWidth)
                .attr('height', magnifierHeight)
                .attr('stroke','white')
                .attr('stroke-width','2px');

            // we draw the magnified planet to fit already here
            // because it never moves
            magnifiedPlanetToFit = magnifier.append('circle')
                .attr('cx', 0.5 * magnifierWidth)
                .attr('cy', 0.5 * magnifierHeight)
                .attr('r', magnification * 5)
                .attr('fill', 'yellow')
                .attr('id', 'magnifiedPlanetToFit')
                .attr('stroke-width', 0);
        }
        setupFigures();

        function defineGradients() {
            var defs = mainFigure.append('defs');

            var gradient0 = defs.append('linearGradient')
               .attr('id', 'gradient0')
               .attr('x1', '50%')
               .attr('x2', '50%')
               .attr('y1', '0%')
               .attr('y2', '100%');

            gradient0.append('stop')
               .attr('class', 'start')
               .attr('offset', '0%')
               .attr('stop-color', '#000')
               .attr('stop-opacity', 1);

            gradient0.append('stop')
               .attr('class', 'end')
               .attr('offset', '100%')
               .attr('stop-color', '#222')
               .attr('stop-opacity', 1);


            var gradient1 = defs.append('linearGradient')
               .attr('id', 'gradient1')
               .attr('x1', '50%')
               .attr('x2', '50%')
               .attr('y1', '0%')
               .attr('y2', '100%');

            gradient1.append('stop')
               .attr('class', 'start')
               .attr('offset', '0%')
               .attr('stop-color', '#DD0')
               .attr('stop-opacity', 1);

            gradient1.append('stop')
               .attr('class', 'end')
               .attr('offset', '100%')
               .attr('stop-color', '#770')
               .attr('stop-opacity', 1);


            var gradient2 = defs.append('linearGradient')
               .attr('id', 'gradient2')
               .attr('x1', '50%')
               .attr('x2', '50%')
               .attr('y1', '0%')
               .attr('y2', '100%');

            gradient2.append('stop')
               .attr('class', 'start')
               .attr('offset', '0%')
               .attr('stop-color', '#0D0')
               .attr('stop-opacity', 1);

            gradient2.append('stop')
               .attr('class', 'end')
               .attr('offset', '100%')
               .attr('stop-color', '#070')
               .attr('stop-opacity', 1);


            var gradient3 = defs.append('linearGradient')
               .attr('id', 'gradient3')
               .attr('x1', '50%')
               .attr('x2', '50%')
               .attr('y1', '0%')
               .attr('y2', '100%');

            gradient3.append('stop')
               .attr('class', 'start')
               .attr('offset', '0%')
               .attr('stop-color', '#D00')
               .attr('stop-opacity', 1);

            gradient3.append('stop')
               .attr('class', 'end')
               .attr('offset', '100%')
               .attr('stop-color', '#700')
               .attr('stop-opacity', 1);


            var gradient4 = defs.append('linearGradient')
               .attr('id', 'gradient4')
               .attr('x1', '50%')
               .attr('x2', '50%')
               .attr('y1', '0%')
               .attr('y2', '100%');

            gradient4.append('stop')
               .attr('class', 'start')
               .attr('offset', '0%')
               .attr('stop-color', '#07F')
               .attr('stop-opacity', 1);

            gradient4.append('stop')
               .attr('class', 'end')
               .attr('offset', '100%')
               .attr('stop-color', '#00F')
               .attr('stop-opacity', 1);


            var gradient5 = defs.append('linearGradient')
               .attr('id', 'gradient5')
               .attr('x1', '50%')
               .attr('x2', '50%')
               .attr('y1', '0%')
               .attr('y2', '100%');

            gradient5.append('stop')
               .attr('class', 'start')
               .attr('offset', '0%')
               .attr('stop-color', '#B0B')
               .attr('stop-opacity', 1);

            gradient5.append('stop')
               .attr('class', 'end')
               .attr('offset', '100%')
               .attr('stop-color', '#505')
               .attr('stop-opacity', 1);
        }
        defineGradients();

        function clearOrbit() {
            remove(orbit);
            orbit = mainFigure.append('path')
                .attr('fill', 'none')
                .attr('stroke', 'none');
            magnifiedOrbit = magnifier.append('path')
                .attr('fill', 'none')
                .attr('stroke', 'none');
        }
        clearOrbit();


        function createSVGElements() {
            // CREATING PLANETS IN SVG AND IN ARRAY //

            planets = [];
            magnifiedPlanets = [];
            planetLabels = [];
            magnifiedPlanetLabels = [];
            var cx = 0.5 * mainWidth;
            var cy = 0.4 * mainHeight;

            // first the planet we wish to fit
            planetToFit = mainFigure.append('circle')
                  .attr('cx', cx + functionToFit(0)[0])
                  .attr('cy', cy + functionToFit(0)[1])
                  .attr('r', 5)
                  .attr('fill', 'yellow')
                  .attr('id', 'planetToFit')
                  .attr('stroke-width', 0);

            // now the other planets
            for (var i = 0; i < nbPlanets; i++) {

                cx += orbitalRadii[i] * Math.cos(orbitalPhases[i]);
                cy -= orbitalRadii[i] * Math.sin(orbitalPhases[i]);
                var newPlanet = mainFigure.append('circle')
                    .attr('class', 'planet')
                    .attr('cx', cx)
                    .attr('cy', cy)
                    .attr('r', bodyRadii[i])
                    .attr('fill', bodyColors[i])
                    .attr('id', planetIDs[i])
                    .attr('stroke-width', 0);
                planets.push(newPlanet);

                // also a magnified version
                var magnifiedCX = magnifierTransform(cx,cy)[0];
                var magnifiedCY = magnifierTransform(cx,cy)[1];
                var magnifiedNewPlanet = magnifier.append('circle')
                    .attr('cx', magnifiedCX)
                    .attr('cy', magnifiedCY)
                    .attr('r', magnification * bodyRadii[i])
                    .attr('fill', bodyColors[i])
                    .attr('stroke-width', 0);
                magnifiedPlanets.push(magnifiedNewPlanet);

                // PLANET LABELS //
                if (i==0) { continue; }

                newPlanetLabel = mainFigure.append('text')
                    .text(orbitalFrequencies[i])
                    .attr('class', 'planet-label')
                    .attr('fill', 'white')
                    .style('font-size', fontScale * planets[i].attr('r') + 'px')
                    .attr('text-anchor', 'middle')
                    .attr('alignment-baseline', 'central')
                    .attr('x', planets[i].attr('cx'))
                    .attr('y', planets[i].attr('cy'))
                    .attr('id', planetIDs[i]);
                planetLabels.push(newPlanetLabel);

                magnifiedNewPlanetLabel = magnifier.append('text')
                    .text(orbitalFrequencies[i])
                    .attr('fill', 'white')
                    .style('font-size', magnification * fontScale * planets[i].attr('r') + 'px')
                    .attr('text-anchor', 'middle')
                    .attr('alignment-baseline', 'central')
                    .attr('x', magnifiedCX)
                    .attr('y', magnifiedCY)
                magnifiedPlanetLabels.push(magnifiedNewPlanetLabel);

            }

            // EPICYCLES //
            epicycles = [];
            magnifiedEpicycles = [];
            for (var i = 1; i< nbPlanets; i++) {
                var cx = +planets[i-1].attr('cx');
                var cy = +planets[i-1].attr('cy');
                var newEpicycle = mainFigure.append('circle')
                    .attr('cx', cx)
                    .attr('cy', cy)
                    .attr('r', orbitalRadii[i])
                    .attr('fill', 'none')
                    .attr('stroke', 'gray')
                    .attr('stroke-width', 2)
                    .attr('opacity', 0.6);
                epicycles.push(newEpicycle);
                var magCX = magnifierTransform(cx,cy)[0];
                var magCY = magnifierTransform(cx,cy)[1];
                var magnifiedNewEpicycle = magnifier.append('circle')
                    .attr('cx', magCX)
                    .attr('cy', magCY)
                    .attr('r', magnification * orbitalRadii[i])
                    .attr('fill', 'none')
                    .attr('stroke', 'gray')
                    .attr('stroke-width', 2)
                    .attr('opacity', 0.6);
                magnifiedEpicycles.push(magnifiedNewEpicycle);
            }

            // LINKS //
            links = [];
            magnifiedLinks = [];
            for (var i = 1; i< nbPlanets; i++) {
                var x0 = planets[i-1].attr('cx');
                var y0 = planets[i-1].attr('cy');
                var x1 = planets[i].attr('cx');
                var y1 = planets[i].attr('cy');
                var newLink = mainFigure.append('path')
                    .attr('d', 'M' + x0 + ' ' + y0 + 'L' + x1 + ' ' + y1)
                    .attr('stroke', 'gray')
                    .attr('stroke-width', 2)
                    .attr('opacity', 0);
                links.push(newLink);

                var magX0 = magnifierTransform(x0,y0)[0];
                var magY0 = magnifierTransform(x0,y0)[1];
                var magX1 = magnifierTransform(x1,y1)[0];
                var magY1 = magnifierTransform(x1,y1)[1];
                var magnifiedNewLink = magnifier.append('path')
                    .attr('d', 'M' + magX0 + ' ' + magY0 + 'L' + magX1 + ' ' + magY1)
                    .attr('stroke', 'gray')
                    .attr('stroke-width', 2)
                    .attr('opacity', 0);
                magnifiedLinks.push(magnifiedNewLink);
            }

            fixHierarchy();
            
            // TRACES (TAILS) //
            trace = mainFigure.append('g')
                .attr('id', 'trace');
            traceArray = [];
            traceToFit = mainFigure.append('g')
                .attr('id', 'traceToFit');
            traceToFitArray = [];

            residual = magnifier.append('g');
            residualBorder = magnifier.append('path')
                .attr('stroke', 'orange')
                .attr('fill', 'none')
                .style('stroke-opacity', 0.5)
                .style('stroke-width', 1);

            residualLabel = magnifier.append('text')
                .text(computedResidual())
                .style('font-size', '20px')
                .attr('fill','white')
                .attr('text-anchor', 'middle')
                .attr('x', magnifierWidth/2)
                .attr('y', magnifierHeight - 30);

        }
        createSVGElements();

        function functionToFit(t) {
            phaseNumber = Math.floor(6 * t / globalPeriod) % 6; // 0,1,2,3,4,5
            alpha = (t % (globalPeriod/6))/(globalPeriod/6);
            hexagonPoints = [
                [1,0],
                [0.5, -Math.sqrt(3)/2],
                [-0.5, -Math.sqrt(3)/2],
                [-1,0],
                [-0.5, Math.sqrt(3)/2],
                [0.5, Math.sqrt(3)/2],
                [1,0]
            ];
            p0 = hexagonPoints[phaseNumber];
            p1 = hexagonPoints[phaseNumber + 1];
            x = 200 * (alpha * p1[0] + (1 - alpha) * p0[0]);
            y = 200 * (alpha * p1[1] + (1 - alpha) * p0[1]);
            return [x,y];
        }        

        function togglePlay() {
            shouldPlay = !shouldPlay;
            if (shouldPlay) {
                deselectPlanet();
                document.getElementById('playButton').src = 'buttons/pause.png';
                document.getElementById('playButton').width = '64px';
                document.getElementById('addPlanetButton').style = 'opacity: 0.6; width: 64px;';
                document.getElementById('removePlanetButton').style = 'opacity: 0.6; width: 64px;';
                timer = d3.timer(play);
            } else {
                timer.stop();
                timestamp += addedTime;
                document.getElementById('playButton').src = 'buttons/play.png';
                document.getElementById('playButton').width = '64px';
                document.getElementById('addPlanetButton').style = 'opacity: 1; width: 64px;';
                document.getElementById('removePlanetButton').style = 'opacity: 1; width: 64px;';
                updateOrbitalData();
            }
        }
        
        var previousX, previousY, nextX, nextY;
        var doneDrawingResidual = false;
        function play(t) {

            addedTime = t; // keep a copy of t for safekeeping once we hit pause
            trueT = timestamp + t; // actual time in simulation

            var residualCenterX = magnifierWidth/2;
            var residualCenterY = magnifierHeight/2;

            var planetToFitCX = +planets[0].attr('cx') + functionToFit(trueT)[0];
            var planetToFitCY = +planets[0].attr('cy') + functionToFit(trueT)[1];
            planetToFit
                .attr('cx', planetToFitCX)
                .attr('cy', planetToFitCY);
            
            var x = +planets[0].attr('cx');
            var y = +planets[0].attr('cy');

            for (var i = 1; i < nbPlanets; i++) {

                var angle = trueT/orbitalPeriods[i] * TAU + orbitalPhases[i];
                x += orbitalRadii[i] * Math.cos(angle);
                y -= orbitalRadii[i] * Math.sin(angle);
                planets[i]
                    .attr('cx', x)
                    .attr('cy', y)
                    .raise();
                planetLabels[i-1]
                    .attr('x', x)
                    .attr('y', y)
                    .raise();

                magnifierX = magnifierTransform(x,y)[0];
                magnifierY = magnifierTransform(x,y)[1];
                magnifiedPlanets[i]
                    .attr('cx', magnifierX)
                    .attr('cy', magnifierY)
                    .raise();
                magnifiedPlanetLabels[i-1]
                    .attr('x', magnifierX)
                    .attr('y', magnifierY)
                    .raise();
            }

            if (shouldDrawTrace) { updateTraces(); }
            updateEpicycles();
            updateLinks();
            fixHierarchy();
            drawMagnifiedOrbitToFit();

            function updateResidualDrawing() {
                nextX = +magnifiedPlanets[nbPlanets - 1].attr('cx');
                nextY = +magnifiedPlanets[nbPlanets - 1].attr('cy');

                if (previousX == undefined && previousY == undefined) { return; }

                var triangleString = 'M' + residualCenterX + ' ' + residualCenterY + 'L' + previousX + ' ' + previousY + 'L' + nextX + ' ' + nextY + 'L' + residualCenterX + ' ' + residualCenterY + 'Z';
                if (residualBorder.attr('d') == undefined) {
                    residualBorder.attr('d', 'M' + previousX + ' ' + previousY);
                } else {
                    var borderString = residualBorder.attr('d');
                    borderString += 'L' + nextX + ' ' + nextY;
                    residualBorder.attr('d', borderString);
                }
                var r1 = [previousX - residualCenterX, previousY - residualCenterY];
                var r2 = [nextX - residualCenterX, nextY - residualCenterY];
                var area = 0.5 * Math.abs(r1[0] * r2[1] - r1[1] * r2[0]);
                var r = (Math.sqrt(r1[0]**2 + r1[1]**2) + Math.sqrt(r2[0]**2 + r2[1]**2))/2;
                var triangleOpacity = opacityFactor * r**2 / area;

                residual.append('path')
                    .attr('d', triangleString)
                    .attr('fill', 'orange')
                    .attr('stroke-width', 0)
                    .attr('opacity', triangleOpacity);

            }
            if (trueT < globalPeriod && residualSpacingCounter % residualSpacing == 0) {
                updateResidualDrawing();
            }
            if (trueT >= globalPeriod && !doneDrawingResidual) {
                updateResidualDrawing();
                var borderString = residualBorder.attr('d');
                borderString += 'Z';
                residualBorder.attr('d', borderString);
                doneDrawingResidual = true;
            }
            residualSpacingCounter += 1;
            previousX = nextX;
            previousY = nextY;

        }

        function computedResidual() {
            var sum = 0;
            var dt = globalPeriod / 20;
            var planetX, planetY, toFitX, toFitY;
            for (var tt = 0; tt < globalPeriod; tt += dt) {
                var p = functionToFit(tt);
                toFitX = p[0];
                toFitY = p[1];
                var q = outermostPlanetPosition(tt);
                planetX = q[0];
                planetY = q[1];
                var r2 = (planetX - toFitX)**2 + (planetY - toFitY)**2;
                sum += r2;
            }
            sum *= dt;
            return sum;
        }

        function updateResidualLabel() {
            residualLabel.text(computedResidual());
        }

        function outermostPlanetPosition(time) {
            var x = +planets[0].attr('cx');
            var y = +planets[0].attr('cy');
            for (var i = 1; i < nbPlanets; i++) {
                var angle = time/globalPeriod * TAU + orbitalPhases[i];
                x += +planets[i].attr('r') * Math.cos(angle);
                y -= +planets[i].attr('r') * Math.sin(angle);
            }
            return [x,y];
        }

        function fixHierarchy() {
            raise(orbit);
            raise(orbitToFit);
            raise(magnifiedOrbit);
            raise(magnifiedOrbitToFit);
            for (var i = 0; i < nbPlanets; i++) {
                raise(planets[i]);
                if (i != 0) { raise(planetLabels[i-1]); }
                magnifiedPlanets[i].raise();
                if (i != 0) { raise(magnifiedPlanetLabels[i-1]); }
            }
            raise(upArrow);
            raise(downArrow);
            raise(upArrowBox);
            raise(downArrowBox);
        }

        function updateEpicycles() {

            var cx = +planets[0].attr('cx');
            var cy = +planets[0].attr('cy');
            var magCX = magnifierTransform(cx,cy)[0];
            var magCY = magnifierTransform(cx,cy)[1];

            for (var i = 1; i < nbPlanets; i++) {
                epicycles[i - 1]
                    .attr('cx', cx)
                    .attr('cy', cy)
                    .attr('r', orbitalRadii[i])
                    .raise();
                magCX = magnifierTransform(cx,cy)[0];
                magCY = magnifierTransform(cx,cy)[1];
                magnifiedEpicycles[i - 1]
                    .attr('cx', magCX)
                    .attr('cy', magCY)
                    .attr('r', magnification * orbitalRadii[i])
                    .raise();

                var angle = trueT/orbitalPeriods[i] * TAU + orbitalPhases[i];
                cx += orbitalRadii[i] * Math.cos(angle);
                cy -= orbitalRadii[i] * Math.sin(angle);

            }

            if (shouldShowEpicycles) { showEpicycles(); }
            else { hideEpicycles(); }

            fixHierarchy();
        }

        function showEpicycles() {
            for (var i = 1; i < nbPlanets; i++) {
                epicycles[i - 1].attr('opacity', 0.6);
                magnifiedEpicycles[i - 1].attr('opacity', 0.6);
            }
        }

        function hideEpicycles() {
            for (var i = 1; i < nbPlanets; i++) {
                epicycles[i - 1].attr('opacity',0);
                magnifiedEpicycles[i - 1].attr('opacity',0);
            }
        }

        function toggleEpicyclesAndLinks() {

            if (shouldShowEpicycles) {
                shouldShowEpicycles = false;
                shouldShowLinks = true;
                document.getElementById('epicyclesButton').src='buttons/links-on.png';
            } else if (shouldShowLinks) {
                shouldShowLinks = false;
                document.getElementById('epicyclesButton').src='buttons/planets.png';
            } else {
                shouldShowEpicycles = true;
                document.getElementById('epicyclesButton').src='buttons/epicycles-on.png';
            }

            if (shouldShowEpicycles) {
                showEpicycles();
            } else {
                hideEpicycles();
            }

            if (shouldShowLinks) {
                showLinks();
            } else {
                hideLinks();
            }
        }

        function updateLinks() {

            for (var i = 1; i < nbPlanets; i++) {
                var x0 = planets[i-1].attr('cx');
                var y0 = planets[i-1].attr('cy');
                var x1 = planets[i].attr('cx');
                var y1 = planets[i].attr('cy');
                links[i - 1].attr('d', 'M' + x0 + ' ' + y0 + 'L' + x1 + ' ' + y1)
                    .raise();
                
                var magX0 = magnifierTransform(x0,y0)[0];
                var magY0 = magnifierTransform(x0,y0)[1];
                var magX1 = magnifierTransform(x1,y1)[0];
                var magY1 = magnifierTransform(x1,y1)[1];
                magnifiedLinks[i - 1].attr('d', 'M' + magX0 + ' ' + magY0 + 'L' + magX1 + ' ' + magY1)
                    .raise();

            }

            if (shouldShowLinks) { showLinks(); }
            else { hideLinks(); }

            fixHierarchy();
        }

        function showLinks() {
            for (var i = 1; i < nbPlanets; i++) {
                links[i - 1].attr('opacity', 0.6);
                magnifiedLinks[i - 1].attr('opacity', 0.6);
            }
        }

        function hideLinks() {
            for (var i = 1; i < nbPlanets; i++) {
                links[i - 1].attr('opacity',0.0);
                magnifiedLinks[i - 1].attr('opacity',0.0);
            }
        }

        function toggleLinks() {
            shouldShowLinks = !shouldShowLinks;
            if (shouldShowLinks) {
                showLinks();
                document.getElementById('linksButton').src='links-on.png';
            } else {
                hideLinks();
                document.getElementById('linksButton').src='links-off.png';
            }
        }

        function updateOrbitalDataForPlanet(i) {
            var ddx = +planets[i].attr('cx') - planets[i-1].attr('cx');
            var ddy = +planets[i].attr('cy') - planets[i-1].attr('cy');
            var rr = (ddx**2 + ddy**2) ** 0.5;
            //var phi = Math.atan2(-ddy, ddx);
            orbitalRadii[i] = rr;
            //orbitalPhases[i] = phi;
        }

        function updateOrbitalData() {
            for (var i = 1; i < nbPlanets; i++) {
                updateOrbitalDataForPlanet(i);
            }
        }

        function updateTraces() {

            traceSpacingCounter = (traceSpacingCounter + 1) % traceSpacing;

            if (traceSpacingCounter != 0) { return; }

            var x = planets[nbPlanets - 1].attr('cx');
            var y = planets[nbPlanets - 1].attr('cy');

            var tracePoint = mainFigure
                .select('#trace')
                .append('circle')
                .attr('cx', x)
                .attr('cy', y)
                .attr('r', 2)
                .attr('fill', 'white');
            traceArray.push(tracePoint);

            x = planetToFit.attr('cx');
            y = planetToFit.attr('cy');
            var traceToFitPoint = mainFigure
                .select('#traceToFit')
                .append('circle')
                .attr('cx', x)
                .attr('cy', y)
                .attr('r', 2)
                .attr('fill', 'yellow');
            traceToFitArray.push(traceToFitPoint);
                
            if (traceArray.length > 20) {
                remove(traceArray[0]);
                traceArray.shift();
            }

            if (traceToFitArray.length > 20) {
                remove(traceToFitArray[0]);
                traceToFitArray.shift();
            }
        }
        updateTraces();

        function drawOrbit() {

            nbSteps = 1000;
            var dt = globalPeriod/nbSteps;
            var fwd_t = 0;
            var x0 = +planets[0].attr('cx');
            var y0 = +planets[0].attr('cy');
            var counter = 0;

            orbitPathString = '';

            while (counter < nbSteps) {
                fwd_t += dt;
                counter += 1;
                var x = x0;
                var y = y0;
                for (var j = 1; j < nbPlanets; j++) {
                    var fwd_angle = fwd_t/globalPeriod*orbitalFrequencies[j] * TAU;
                    var r = +orbitalRadii[j];
                    var phi = +orbitalPhases[j];
                    x += r * Math.cos(fwd_angle + phi);
                    y -= r * Math.sin(fwd_angle + phi);
                }
                if (counter == 1) {
                    orbitPathString += 'M';
                } else {
                    orbitPathString += 'L';
                }
                orbitPathString += x + ' ' + y;
            }
            orbitPathString += 'Z';

            remove(orbit);
            orbit = mainFigure.append('path')
                .attr('id','orbit')
                .attr('d', orbitPathString)
                .attr('fill', 'none')
                .attr('stroke', 'white')
                .attr('stroke-width', 2)
                .attr('transform', mainFigure.attr('transform')); 

            fixHierarchy();
        }

        function drawOrbitToFit() {
            nbSteps = 1000;
            var dt = globalPeriod/nbSteps;
            var fwd_t = 0;
            var x0 = +planets[0].attr('cx');
            var y0 = +planets[0].attr('cy');
            var counter = 0;

            pathString = '';

            while (counter < nbSteps) {
                fwd_t += dt;
                counter += 1;
                p = functionToFit(fwd_t);
                x = x0 + p[0];
                y = y0 + p[1];

                if (counter == 1) {
                    pathString += 'M';
                } else {
                    pathString += 'L';
                }
                pathString += x + ' ' + y;
            }
            pathString += 'Z';

            remove(orbitToFit);
            orbitToFit = mainFigure.append('path')
                .attr('id','orbitToFit')
                .attr('d', pathString)
                .attr('fill', 'none')
                .attr('stroke', 'yellow')
                .attr('stroke-width', 2)
                .attr('transform', mainFigure.attr('transform'));

            fixHierarchy();
        }
        //drawOrbitToFit();

        function drawMagnifiedOrbitToFit() {
            nbSteps = 1000;
            var dt = globalPeriod/nbSteps;
            var t = 0;
            var x0 = +planets[0].attr('cx');
            var y0 = +planets[0].attr('cy');
            var counter = 0;

            magnifierPathString = '';

            while (counter < nbSteps) {
                t += dt;
                counter += 1;
                p = functionToFit(t);
                x = x0 + p[0];
                y = y0 + p[1];

                if (counter == 1) {
                    magnifierPathString += 'M';
                } else {
                    magnifierPathString += 'L';
                }
                var magnifierX = magnifierTransform(x,y)[0];
                var magnifierY = magnifierTransform(x,y)[1];
                magnifierPathString += magnifierX + ' ' + magnifierY;
            }
            magnifierPathString += 'Z';

            remove(magnifiedOrbit);
            magnifiedOrbit = magnifier.append('path')
                .attr('id','orbitToFit')
                .attr('d', magnifierPathString)
                .attr('fill', 'none')
                .attr('stroke', 'yellow')
                .attr('stroke-width', 2);
        }
        drawMagnifiedOrbitToFit();

        function toggleTrace() {
            shouldDrawOrbit = !shouldDrawOrbit;
            shouldDrawTrace = !shouldDrawTrace;
            if (shouldDrawOrbit) {
                eraseTraces();
                drawOrbit();
                drawOrbitToFit();
                document.getElementById('trace_button').src = 'buttons/show_orbit.png';
            }
            if (shouldDrawTrace) {
                remove(orbit);
                remove(orbitToFit);
                updateTraces();
                document.getElementById('trace_button').src = 'buttons/show_trace.png';
            }
        }

        function eraseTraces() {
            for (var i = 0; i < traceArray.length; i++) {
                remove(traceArray[i]);
                remove(traceToFitArray[i]);
            }
            traceArray = [];
            traceToFitArray = [];
        }

        function makePlanetsDraggable() {

            function anchorDragStart() {
                var b = d3.select(this); // the planet or label registering the drag
                var ii = +b.attr('id');
                var p = planets[ii];
                dragstartX = zoomInverseTransformX(d3.event.x) - p.attr('cx');
                dragstartY = zoomInverseTransformY(d3.event.y) - p.attr('cy');
                // relative to initial planet center
                b.style('cursor', 'grabbing');
            }

            function dragPlanet() {

                deselectPlanet();
                eraseTraces();
                addedTime = 0;
              
                var b = d3.select(this); // the planet or label registering the drag
                var ii = +b.attr('id');
                draggedPlanet = planets[ii];
                dx = zoomInverseTransformX(d3.event.x) - dragstartX - draggedPlanet.attr('cx');
                dy = zoomInverseTransformY(d3.event.y) - dragstartY - draggedPlanet.attr('cy');

                var planetScaler = 1;

                for (var i = ii; i < planets.length; i++) {
                    
                    var planet = planets[i];
                    var magnifiedPlanet = magnifiedPlanets[i];
                    var oldCX = +planet.attr('cx');
                    var oldCY = +planet.attr('cy');
                    var newCX = oldCX + dx;
                    var newCY = oldCY + dy;
                    var magNewCX = magnifierTransform(newCX,newCY)[0];
                    var magNewCY = magnifierTransform(newCX,newCY)[1];


                    planet
                        .attr('cx', newCX)
                        .attr('cy', newCY)
                    magnifiedPlanet
                        .attr('cx', magNewCX)
                        .attr('cy', magNewCY);


                    if (i != 0) {
                        var label = planetLabels[i - 1];
                        var magnifiedLabel = magnifiedPlanetLabels[i - 1];
                        label
                            .attr('x', newCX)
                            .attr('y', newCY);
                        magnifiedLabel
                            .attr('x', magNewCX)
                            .attr('y', magNewCY);
                    }
                    
                    if (i != 0) {
                        updateOrbitalDataForPlanet(i);
                    }
                    

                }

                if (ii != 0) {
                    var grabbedPlanet = planets[ii];
                    var parentPlanet = planets[ii - 1];
                    var ddx = +grabbedPlanet.attr('cx') - parentPlanet.attr('cx');
                    var ddy = +grabbedPlanet.attr('cy') - parentPlanet.attr('cy');
                    var linkLength = Math.sqrt(ddx**2 + ddy**2);
                    var r1 = +bodyRadii[ii];
                    var r2 = +bodyRadii[ii - 1];
                    var planetScaler = Math.min(1, radiusBufferRatio * linkLength / (r1 + r2));

                    for (var i = ii - 1; i < nbPlanets; i++) {
                        planets[i].attr('r', +bodyRadii[i] * planetScaler);
                        magnifiedPlanets[i].attr('r', +bodyRadii[i] * planetScaler * magnification);
                    }
                    for (var i = Math.max(0,ii - 2); i < nbPlanets - 1; i++) {
                        planetLabels[i].style('font-size', +planets[i + 1].attr('r') * fontScale);
                        magnifiedPlanetLabels[i].style('font-size', +magnifiedPlanets[i + 1].attr('r') * fontScale);
                    }

                }

                if (shouldDrawOrbit) { drawOrbit(); }
                updateEpicycles();
                updateLinks();
                updateResidualLabel();
            }


            function dragEnd() {
                d3.select(this).style('cursor','grab');
                // comment to make this function collapsible
            }

            dragHandler = d3.drag()
                .on('start', anchorDragStart)
                .on('drag', dragPlanet)
                .on('end', dragEnd)

            dragHandler(mainFigure.selectAll('circle'));
            dragHandler(mainFigure.selectAll('text'));
        }
        makePlanetsDraggable();


        function makeFrequenciesEditable() {
            
            mainFigure.selectAll('circle').on('click', selectPlanet);
            mainFigure.selectAll('text').on('click', selectPlanet);
        }
        makeFrequenciesEditable();

        function selectPlanet() {

            function incrementFrequency() {
                var ii;
                eraseTraces();
                var b = d3.select(this); // the clicked arrow
                for (var i = 1; i < planets.length; i++) {
                    if (planetLabels[i - 1].attr('id') == b.attr('id')) {
                        ii = i;
                    }
                }

                orbitalFrequencies[ii]++;
                orbitalPeriods[ii] = globalPeriod/orbitalFrequencies[ii];
                planetLabels[ii-1].text(orbitalFrequencies[ii]);
                if (shouldDrawOrbit) { drawOrbit(); }
            }

            function decrementFrequency() {
                var ii;
                eraseTraces();
                var b = d3.select(this); // the clicked arrow
                for (var i = 1; i < planets.length; i++) {
                    if (planetLabels[i - 1].attr('id') == b.attr('id')) {
                        ii = i;
                    }
                }
                orbitalFrequencies[ii]--;
                orbitalPeriods[ii] = globalPeriod/orbitalFrequencies[ii];
                planetLabels[ii-1].text(orbitalFrequencies[ii]);
                if (shouldDrawOrbit) { drawOrbit(); }
            }

            deselectPlanet();
            var ii = +d3.select(this).attr('id');
            if (ii == 0) { return; }
            var planet = planets[ii];
            selectedPlanet = planet;

            for (var i = 0; i < nbPlanets; i++) {
                if (i != ii) {
                    planets[i].attr('opacity', 0.3);
                    if (i != 0) { planetLabels[i - 1].attr('opacity', 0.3); }
                }
            }

            upArrow = mainFigure.append('text')
                .text('⬆︎')
                .attr('class', 'incrementer')
                .style('font-size', planet.attr('r') + 'px')
                .attr('fill','white')
                .attr('text-anchor', 'middle')
                .attr('x', +planet.attr('cx'))
                .attr('y', +planet.attr('cy') - 1.2 * planet.attr('r'))
                .attr('id', planet.attr('id'))
                .attr('transform',T);
            downArrow = mainFigure.append('text')
                .text('⬇')
                .attr('class', 'incrementer')
                .style('font-size', planet.attr('r') + 'px')
                .attr('fill','white')
                .attr('text-anchor', 'middle')
                .attr('x', +planet.attr('cx'))
                .attr('y', +planet.attr('cy') + 2 * planet.attr('r'))
                .attr('id', planet.attr('id'))
                .attr('transform',T);
            upArrow.on('click', incrementFrequency);
            downArrow.on('click', decrementFrequency);
        }


        function addPlanet() {
            if (shouldPlay) { return; }

            nbPlanets++;
            eraseTraces();
            setupPlanetLooks(nbPlanets);
            clearOrbit();

            var minRadius = (bodyRadii[nbPlanets - 1] + bodyRadii[nbPlanets - 2])/radiusBufferRatio;
            orbitalRadii[nbPlanets - 1] = Math.max(orbitalRadii[nbPlanets - 2]/3, minRadius);
            orbitalFrequencies[nbPlanets - 1] = 1;
            orbitalPeriods[nbPlanets - 1] = globalPeriod/orbitalFrequencies[nbPlanets - 1];
            orbitalPhases[nbPlanets - 1] = 0;

            var cx = +planets[0].attr('cx');
            var cy = +planets[0].attr('cy');
            for (var i = 0; i < nbPlanets - 1; i++) {
                cx += orbitalRadii[i] * Math.cos(orbitalPhases[i]);
                cy -= orbitalRadii[i] * Math.sin(orbitalPhases[i]);
            }

            var newEpicycle = mainFigure.append('circle')
                .attr('cx',cx)
                .attr('cy',cy)
                .attr('stroke','gray')
                .attr('stroke-width', 2)
                .attr('fill','none')
                .attr('transform',T);
            epicycles.push(newEpicycle);

            newCX = cx + orbitalRadii[nbPlanets - 1] * Math.cos(orbitalPhases[nbPlanets - 1]);
            newCY = cy - orbitalRadii[nbPlanets - 1] * Math.sin(orbitalPhases[nbPlanets - 1]);


            var newLink = mainFigure.append('path')
                .attr('d', 'M' + cx + ' ' + cy + 'L' + newCX + ' ' + newCY)
                .attr('stroke', 'gray')
                .attr('stroke-width', 2)
                .attr('transform',T);
            links.push(newLink);

            magnifiedCX = magnifierTransform(cx,cy)[0];
            magnifiedCY = magnifierTransform(cx,cy)[1];
            magnifiedNewCX = magnifierTransform(newCX,newCY)[0];
            magnifiedNewCY = magnifierTransform(newCX,newCY)[1];
            console.log(newCX, magnifiedNewCX);


            var magnifiedNewEpicycle = magnifier.append('circle')
                .attr('cx',magnifiedCX)
                .attr('cy',magnifiedCY)
                .attr('stroke','gray')
                .attr('stroke-width', 2)
                .attr('fill','none')
                .attr('transform',T);
            magnifiedEpicycles.push(magnifiedNewEpicycle);

            var magnifiedNewLink = magnifier.append('path')
                .attr('d', 'M' + magnifiedCX + ' ' + magnifiedCY + 'L' + magnifiedNewCX + ' ' + magnifiedNewCX)
                .attr('stroke', 'gray')
                .attr('stroke-width', 2)
                .attr('transform',T);
            magnifiedLinks.push(magnifiedNewLink);

            if (shouldShowLinks) {
                newLink.attr('opacity', 0.6);
                magnifiedNewLink.attr('opacity', 0.6);
                showLinks();
            } else {
                newLink.attr('opacity', 0);
                magnifiedNewLink.attr('opacity', 0);
                hideLinks();
            }

            var newPlanet = mainFigure.append('circle')
                .attr('class','planet')
                .attr('cx', newCX)
                .attr('cy', newCY)
                .attr('r', bodyRadii[nbPlanets - 1])
                .attr('fill', bodyColors[nbPlanets - 1])
                .attr('id', planetIDs[nbPlanets - 1])
                .attr('stroke', 'none')
                .attr('transform',T);
            planets.push(newPlanet);

            var newPlanetLabel = mainFigure.append('text')
                .text(orbitalFrequencies[nbPlanets - 1])
                .attr('class', 'planet-label')
                .attr('fill', 'white')
                .style('font-size', fontScale * planets[nbPlanets - 1].attr('r') + 'px')
                .attr('text-anchor', 'middle')
                .attr('alignment-baseline', 'central')
                .attr('x', planets[nbPlanets - 1].attr('cx'))
                .attr('y', planets[nbPlanets - 1].attr('cy'))
                .attr('id', planets[nbPlanets - 1].attr('id'))
                .attr('transform',T)
                .raise();
            planetLabels.push(newPlanetLabel);

            var newMagnifiedPlanet = magnifier.append('circle')
                .attr('class','magnified-planet')
                .attr('cx', magnifiedNewCX)
                .attr('cy', magnifiedNewCY)
                .attr('r', bodyRadii[nbPlanets - 1] * magnification)
                .attr('fill', bodyColors[nbPlanets - 1])
                .attr('id', planetIDs[nbPlanets - 1])
                .attr('stroke', 'none');
            magnifiedPlanets.push(newMagnifiedPlanet);

            var magnifiedNewPlanetLabel = magnifier.append('text')
                .text(orbitalFrequencies[nbPlanets - 1])
                .attr('class', 'magnified-planet-label')
                .attr('fill', 'white')
                .style('font-size', fontScale * magnifiedPlanets[nbPlanets - 1].attr('r') + 'px')
                .attr('text-anchor', 'middle')
                .attr('alignment-baseline', 'central')
                .attr('x', magnifiedPlanets[nbPlanets - 1].attr('cx'))
                .attr('y', magnifiedPlanets[nbPlanets - 1].attr('cy'))
                .attr('id', magnifiedPlanets[nbPlanets - 1].attr('id'));
            magnifiedPlanetLabels.push(magnifiedNewPlanetLabel);


            dragHandler(newPlanet);
            dragHandler(newPlanetLabel);
            newPlanet.on('click', selectPlanet);
            newPlanetLabel.on('click', selectPlanet);

            updateEpicycles();
            if (shouldDrawOrbit) { drawOrbit(); }
        }
    
        function removePlanet() {
            
            if (shouldPlay) { return; }
            eraseTraces();
            remove(planets[nbPlanets - 1]);
            remove(planetLabels[nbPlanets - 2]);
            remove(epicycles[nbPlanets - 2]);
            remove(links[nbPlanets - 2]);
            planets.pop();
            planetLabels.pop();
            epicycles.pop();
            links.pop();

            nbPlanets--;
            setupPlanets(nbPlanets);
            clearOrbit();
            if (shouldDrawOrbit) { drawOrbit(); }
        }
    
        function deselectPlanet() {
            if (selectedPlanet != undefined) {
                selectedPlanet.attr('stroke-width', 2);
                for (var i = 0; i < nbPlanets; i++) {
                    planets[i].attr('opacity', 1);
                    if (i < nbPlanets - 1) {
                        planetLabels[i].attr('opacity', 1);
                    }
                }
                selectedPlanet = undefined;
            }
            remove(upArrow);
            upArrow = undefined;
            remove(downArrow);
            downArrow = undefined;
            remove(upArrowBox);
            upArrowBox = undefined;
            remove(downArrowBox);
            downArrowBox = undefined;
        }

        function mainFigureZoom() {
            eraseTraces();
            T = d3.event.transform;
            mainFigure.attr('transform', T);
            mainFigure.selectAll('circle').attr('transform', T);
            mainFigure.selectAll('path').attr('transform', T);
            mainFigure.selectAll('g').attr('transform', T);
            mainFigure.selectAll('text').attr('transform', T);
            adjustMagnifier(magnification);
        }


        function adjustMagnifier(newMagnification) {
            var newScale = +T.k * newMagnification;
            var magT1 = 'translate(' + 0.5 * magnifierWidth + ',' + 0.5 * magnifierHeight + ') ';
            var magT2 = 'scale(' + newScale + ') ';
            var magT3 = 'translate(-' + 0.5 * magnifierWidth + ',-' + 0.5 * magnifierHeight + ')';
            var magT = magT1 + magT2 + magT3;
            magnifier.attr('transform', magT);
            magnifier.selectAll('circle').attr('transform', magT);
            magnifier.selectAll('path').attr('transform', magT);
            magnifier.selectAll('g').attr('transform', magT);
            magnifier.selectAll('text').attr('transform', magT);

        }

        var magTraw;
        function magnifierZoom() {
            magTraw = d3.event.transform;
            magnification = Math.max(+magTraw.k * originalMagnification, originalMagnification);
            adjustMagnifier(magnification);
        }


        function zoomTransformX(x) {
            return T.k * x + T.x;
        }

        function zoomTransformY(y) {
            return T.k * y + T.y;
        }
    
        function zoomInverseTransformX(x) {
            return (x - T.x)/T.k;
        }

        function zoomInverseTransformY(y) {
            return (y - T.y)/T.k;
        }

        function magnifierTransform(x,y) {
            var x0 = +planetToFit.attr('cx');
            var y0 = +planetToFit.attr('cy');
            var x1 = magnifierWidth/2;
            var y1 = magnifierHeight/2;
            transformedX = x1 + magnification * (x - x0);
            transformedY = y1 + magnification * (y - y0);
            return [transformedX, transformedY];
        }

        function magnifierTransformString() {
            var x0 = +planetToFit.attr('cx');
            var y0 = +planetToFit.attr('cy');
            var x1 = magnifierWidth/2;
            var y1 = magnifierHeight/2;
            T1 = 'translate(-' + x0 + ',-' + y0 + ')';
            T2 = 'scale(' + magnification + ')';
            T1 = 'translate(' + x1 + ',' + y1 + ')';
            return T3 + T2 + T1;
        }
    </script>

    <br/>
    <div style='text-align: center;' class='button-div'>
        <img onclick='togglePlay();' id='playButton' style='width: 64px;' src='buttons/play.png'></img>
        <img onclick='addPlanet();' id='addPlanetButton' style='width: 64px;' src='buttons/plus.png'></img>
        <img onclick='removePlanet();' id='removePlanetButton' style='width: 64px;' src='buttons/minus.png'></img>
        <img onclick='toggleEpicyclesAndLinks();' id='epicyclesButton' style='width: 64px;' src='buttons/epicycles-on.png'></img>
        <img onclick='toggleTrace();' id='trace_button' style='width: 64px;' src='buttons/show_trace.png'></img>
        <!--<input type='checkbox' name='venus' value='venus'
               value='show_venus' /><label for='venus'></label>-->
    </div>
    <!--<script>


        venusCheckbox = document.querySelector('input[value='venus']');
        venusCheckbox.onchange = function() {
            if (venusCheckbox.checked) {
                venusImage = d3.selectAll('svg').insert('image','rect')
                    .attr('xlink:href', 'https://upload.wikimedia.org/wikipedia/commons/thumb/8/89/Venus_geocentric_orbit_curve_simplified_Line_%28pentagram%29.svg/602px-Venus_geocentric_orbit_curve_simplified_Line_%28pentagram%29.mainFigure.png')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', mainWidth)
                    .attr('height', mainHeight)
                    .attr('opacity', 0.2);
            } else {
                if (venusImage != undefined) {
                    venusImage.remove();
                }
            }
        };
    </script>-->
    


</body>

