<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <script src="d3.v4.min.js"></script>
    <style>
        body { margin:0;position:fixed;top:0;right:0;bottom:0;left:0; }
        svg text {
            -webkit-user-select: none;
            -webkit-moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            cursor: default; 
        }
        svg text::selection {
            background: none;
        }

    </style>
</head>

<body>
    <script>

        function linspace(xmin,xmax,n) {
            if (n < 1) {
                return [];
            } else if (n == 1) {
                return [(xmin + xmax)/2];
            }
            else {
                dx = (xmax - xmin)/(n-1);
                var retarr = [xmin];
                for (var i = 1; i < n; i++) {
                    retarr.push(xmin + i * dx);
                }
                return retarr;
            }
        }

        function colorwheel(n) {
            var nb_copies = Math.ceil(n/5);
            var retarr = [];
            for (var i = 0; i < nb_copies; i++) {
                retarr = retarr.concat(['yellow', 'green', 'red', 'cyan', 'gray']);
            }
            return retarr.slice(0,n);
        }


        // CONSTANTS //

        var TAU = 6.283185;
        
        var svg_width = 550;
        var svg_height = 550;

        var nb_bodies = 3;
        var global_period = 6000;

        var body_radii, body_colors, ids, orbital_radii, orbital_frequencies, orbital_periods, orbital_phases, shouldDrawTraces, shouldDrawOrbits, fwd_orbits, back_orbits;


        var body = d3.select("body");
        var svg = body.append("svg")
            .attr("width", svg_width)
            .attr("height",svg_height);


        function clearOrbits() {
            // INSTANTIATING FORWARD AND BACK ORBITS //
            // again in svg and in an array
            svg.selectAll("path").remove();

            fwd_orbits = [];
            for (var i = 0; i < nb_bodies; i++) {
                var new_orbit = svg.append("path")
                    .attr("fill", "none")
                    .attr("stroke", "none");
                fwd_orbits.push(new_orbit);
            }
            back_orbits = [];
            for (var i = 0; i < nb_bodies; i++) {
                var new_orbit = svg.append("path")
                    .attr("fill", "none")
                    .attr("stroke", "black");
                back_orbits.push(new_orbit);
            }
        }

        function setupPlanets(n) {
            body_radii = linspace(30,20,nb_bodies);
            body_colors = colorwheel(nb_bodies);
            ids = body_radii;

            shouldDrawTraces = [];
            shouldDrawOrbits = [];
            for (var i = 0; i < nb_bodies; i++) {
                shouldDrawTraces.push(false);
                shouldDrawOrbits.push(false);
            }
            shouldDrawOrbits[nb_bodies - 1] = true;

        }
        
        function setupOrbits(n) {
            
            orbital_radii = linspace(100,20,nb_bodies);
            orbital_radii[0] = 0;

            orbital_frequencies = linspace(0,nb_bodies - 1, nb_bodies);
            orbital_periods = [];
            for (var i = 0; i < nb_bodies; i++) {
                orbital_periods.push(global_period/orbital_frequencies[i]);
            }
            orbital_phases = [];
            for (var i = 0; i < nb_bodies; i++) {
                orbital_phases.push(Math.random() * TAU);
            }

        }
        
        setupPlanets(nb_bodies);
        setupOrbits(nb_bodies);
        clearOrbits();

        // CREATING PLANETS IN SVG AND IN ARRAY //

        var heavenly_bodies = [];
        var cx = svg_width/2;
        var cy = svg_height/2;
        for (var i = 0; i < nb_bodies; i++) {
              cx += orbital_radii[i] * Math.cos(orbital_phases[i]);
              cy -= orbital_radii[i] * Math.sin(orbital_phases[i]);
              var new_body = svg.append("circle")
              .attr("cx", cx)
              .attr("cy", cy)
              .attr("r", body_radii[i])
              .attr("fill", body_colors[i])
              .attr("id", ids[i])
              .attr("stroke", "black");
              heavenly_bodies.push(new_body);
        }

        // PLANET LABELS //
        var planet_labels = [];
        for (var i = 1; i < nb_bodies; i++) {
            new_label = svg.append("text")
            .text(orbital_frequencies[i])
            .attr('text-anchor', 'middle')
            .attr('alignment-baseline', 'ideographic')
            .attr('x', heavenly_bodies[i].attr('cx'))
            .attr('y', heavenly_bodies[i].attr('cy'));
            planet_labels.push(new_label);
        }


        // EPICYCLE CIRCLES //
        var epicycles = [];
        for (var i = 1; i< nb_bodies; i++) {
            var new_epicycle = svg.append("circle")
                .attr("cx", heavenly_bodies[i-1].attr("cx"))
                .attr("cy", heavenly_bodies[i-1].attr("cy"))
                .attr("r", orbital_radii[i])
                .attr("fill", "none")
                .attr("stroke", "black")
                .attr("opacity", 0.3);
            epicycles.push(new_epicycle);
        }
        
        // TRACES (TAILS) //
        var traces = [];
        var trace_arrays = [];
        for (var i = 0; i < nb_bodies; i++) {
            traces[i] = svg.append("g");
            trace_arrays[i] = [];
        }
        var traceSpacing = 5;
        var traceSpacingCounter = 0;
        
        // CREATING TIMER //
        var timestamp = 0;
        var addedTime = 0; // time shift incremented whenever stopping
        var timer = d3.timer(playOrbit)
             .stop();
        
        var shouldPlay = false;
        function togglePlay() {
            shouldPlay = !shouldPlay;
            if (shouldPlay) {
                timer = d3.timer(playOrbit);
            } else {
                timer.stop();
                timestamp += addedTime;
                updateOrbitalData();
            }
        }
        
        function playOrbit(t) {

            addedTime = t;
            updateEpicycles();
          
            var x = +heavenly_bodies[0].attr('cx');
            var y = +heavenly_bodies[0].attr('cy');

            for (var i = 1; i < nb_bodies; i++) {

                var angle = t/orbital_periods[i] * TAU + orbital_phases[i];
                x += orbital_radii[i] * Math.cos(angle);
                y -= orbital_radii[i] * Math.sin(angle);
                heavenly_bodies[i]
                    .attr("cx", x)
                    .attr("cy", y)
                    .raise();
                planet_labels[i-1]
                    .attr('x', x)
                    .attr('y', y)
                    .raise();

                if (shouldDrawTraces[i]) { updateTraceOfPlanet(i); }
                if (shouldDrawOrbits[i]) { drawOrbitForPlanet(i,t); }

            }

        }

        function updateEpicycles() {

            var x = +heavenly_bodies[0].attr('cx');
            var y = +heavenly_bodies[0].attr('cy');

            for (var i = 1; i < nb_bodies; i++) {
                epicycles[i - 1]
                    .attr("cx", x)
                    .attr("cy", y)
                    .attr("r", orbital_radii[i])
                    .raise();
                var angle = (addedTime)/orbital_periods[i] * TAU + orbital_phases[i];
                x += orbital_radii[i] * Math.cos(angle);
                y -= orbital_radii[i] * Math.sin(angle);

            }
        }

        function updateOrbitalDataForPlanet(i) {
            var ddx = +heavenly_bodies[i].attr('cx') - heavenly_bodies[i-1].attr('cx');
            var ddy = +heavenly_bodies[i].attr('cy') - heavenly_bodies[i-1].attr('cy');
            r = (ddx**2 + ddy**2) ** 0.5;
            phi = Math.atan2(-ddy, ddx);
            orbital_radii[i] = r;
            orbital_phases[i] = phi;
        }

        function updateOrbitalData() {
            for (var i = 1; i < nb_bodies; i++) {
                updateOrbitalDataForPlanet(i);
            }
        }

        function updateTraceOfPlanet(i) {

            traceSpacingCounter = (traceSpacingCounter + 1) % traceSpacing;

            if (traceSpacingCounter != 0) { return; }

            var tracePoint = d3.select("svg")
                .select("g")
                .append("circle")
                .attr("cx", x)
                .attr("cy", y)
                .attr("r", 1)
                .attr("fill", "black");
                
            trace_arrays[i].push(tracePoint);
                
            if (traces[i].length > 20) {
                trace_arrays[i][0].remove();
                trace_arrays[i].shift();
            }

        }

        drawOrbits(timestamp);

        function drawOrbits(tt) {
            for (var i = 0; i < nb_bodies; i++) {
                if (shouldDrawOrbits[i]) { drawOrbitForPlanet(i, tt); }
            }
        }

        function drawOrbitForPlanet(i, tt) {

            //f = Math.abs(orbital_frequencies[i]);
            R = orbital_radii[i];
            nb_steps = 1000;
            var dt = global_period/nb_steps;
            // if (f != 0) {
            //     dt = 0.005 * global_period/f;
            // } else {
            //     dt = 0.005 * global_period;
            // }
            
            var fwd_t = +tt;
            var back_t = +tt;
            var start_x = +heavenly_bodies[i].attr('cx');
            var start_y = +heavenly_bodies[i].attr('cy');
            var x0 = +heavenly_bodies[0].attr('cx');
            var y0 = +heavenly_bodies[0].attr('cy');
            var fwd_x = Infinity;
            var fwd_y = Infinity;
            var back_x = Infinity;
            var back_y = Infinity;
            var counter = 0;

            fwd_orbit_path_string = "M" + start_x + " " + start_y;
            back_orbit_path_string = fwd_orbit_path_string;

            while (counter < nb_steps) {
                fwd_t += dt;
                back_t -= dt;
                counter += 1;
                fwd_x = x0;
                fwd_y = y0;
                back_x = x0;
                back_y = y0;
                for (var j = 1; j <= i; j++) {
                    var fwd_angle = fwd_t/global_period*orbital_frequencies[j] * TAU;
                    var back_angle = back_t/global_period*orbital_frequencies[j] * TAU;
                    var r = +orbital_radii[j];
                    var phi = +orbital_phases[j];
                    fwd_x += r * Math.cos(fwd_angle + phi);
                    fwd_y -= r * Math.sin(fwd_angle + phi);
                    back_x += r * Math.cos(back_angle + phi);
                    back_y -= r * Math.sin(back_angle + phi);
                }
                fwd_orbit_path_string += "L" + fwd_x + " " + fwd_y;
                back_orbit_path_string += "L" + back_x + " " + back_y;
            }

            fwd_orbits[i].remove();
            fwd_orbits[i] = svg.append('path')
                .attr("d", fwd_orbit_path_string)
                .attr("fill", "none")
                .attr("stroke", "none"); 

            back_orbits[i].remove();
            back_orbits[i] = svg.append('path')
                .attr("d", back_orbit_path_string)
                .attr("fill", "none")
                .attr("stroke", "black");   
        }



        var dragHandler = d3.drag().on("drag", function() {

            addedTime = 0;
          
            dx = d3.event.x - d3.select(this).attr('cx');
            dy = d3.event.y - d3.select(this).attr('cy');
          
            var ii;
            var b = d3.select(this); // the planet registering the drag
            for (var i = 0; i < heavenly_bodies.length; i++) {
                if (heavenly_bodies[i].attr('id') == b.attr('id')) {
                    ii = i;
                    if (i != 0) {
                        updateOrbitalDataForPlanet(ii);
                    }
                }
                if (i >= ii) {
                    planet = heavenly_bodies[i];
                    old_cx = +planet.attr('cx');
                    old_cy = +planet.attr('cy');
                    planet
                        .attr('cx', old_cx + dx)
                        .attr('cy', old_cy + dy);
                    if (i != 0) {
                        label = planet_labels[i-1];
                        label
                            .attr('x', old_cx + dx)
                            .attr('y', old_cy + dy);
                    }
                }
                if (i != 0) {
                    updateOrbitalDataForPlanet(i);
                }
            }
            drawOrbits(0);
            updateEpicycles();

        });

        dragHandler(d3.select("svg").selectAll("circle"));
        
        function increment_frequency() {
            var ii;
            var clickedOnEpicycle = true;
            var b = d3.select(this); // the planet registering the drag
            for (var i = 0; i < heavenly_bodies.length; i++) {
                if (heavenly_bodies[i].attr('id') == b.attr('id')) {
                    ii = i;
                    clickedOnEpicycle = false;
                }
            }
            if (clickedOnEpicycle) {return;}

            if (d3.event.y < +b.attr('cy')) {
                orbital_frequencies[ii]++;
            } else {
                orbital_frequencies[ii]--;
            }
            orbital_periods[ii] = global_period/orbital_frequencies[ii];
            planet_labels[ii-1].text(orbital_frequencies[ii]);
            drawOrbits(0);
        }

        d3.select('svg').selectAll('circle').on("click", increment_frequency);

    
    
    function addPlanet() {

        if (shouldPlay) { return; }

        nb_bodies++;
        setupPlanets(nb_bodies);
        clearOrbits();

        for (var i = 0; i < nb_bodies - 1; i++) {
            heavenly_bodies[i]
                .attr("r", body_radii[i])
                .attr("fill", body_colors[i])
                .attr("id", ids[i]);
        }
        orbital_radii[nb_bodies - 1] = orbital_radii[nb_bodies - 2];
        orbital_frequencies[nb_bodies - 1] = 0;
        orbital_periods[nb_bodies - 1] = global_period/orbital_frequencies[nb_bodies - 1];
        orbital_phases[nb_bodies - 1] = 0;

        var cx = +heavenly_bodies[0].attr('cx');
        var cy = +heavenly_bodies[0].attr('cy');
        for (var i = 0; i < nb_bodies - 1; i++) {
            cx += orbital_radii[i] * Math.cos(orbital_phases[i]);
            cy -= orbital_radii[i] * Math.sin(orbital_phases[i]);
        }

        var new_epicycle = svg.append('circle')
            .attr('cx',cx)
            .attr('cy',cy)
            .attr('stroke','gray')
            .attr('fill','none');
        epicycles.push(new_epicycle);

        cx += orbital_radii[nb_bodies - 1] * Math.cos(orbital_phases[nb_bodies - 1]);
        cy -= orbital_radii[nb_bodies - 1] * Math.sin(orbital_phases[nb_bodies - 1]);

        var new_body = svg.append("circle")
            .attr("cx", cx)
            .attr("cy", cy)
            .attr("r", body_radii[nb_bodies - 1])
            .attr("fill", body_colors[nb_bodies - 1])
            .attr("id", ids[nb_bodies - 1])
            .attr("stroke", "black");
        heavenly_bodies.push(new_body);

        var new_label = svg.append("text")
            .text(orbital_frequencies[nb_bodies - 1])
            .attr('text-anchor', 'middle')
            .attr('alignment-baseline', 'ideographic')
            .attr('x', heavenly_bodies[nb_bodies - 1].attr('cx'))
            .attr('y', heavenly_bodies[nb_bodies - 1].attr('cy'));
        planet_labels.push(new_label);

        dragHandler(new_body);
        new_body.on("click", increment_frequency);

        updateEpicycles();
        drawOrbits(0);

    }
    
    function removePlanet() {
        
        if (shouldPlay) { return; }
        console.log(nb_bodies);
        heavenly_bodies[nb_bodies - 1].remove();
        planet_labels[nb_bodies - 2].remove();
        epicycles[nb_bodies - 2].remove();
        heavenly_bodies.pop();
        planet_labels.pop();
        epicycles.pop();

        nb_bodies--;
        setupPlanets(nb_bodies);
        clearOrbits();
        drawOrbits(0);
    }
    
    
    
    
    
    
    
    

    </script>
    <br/>   
    <button onclick="togglePlay();" id='play_button'>Play/Pause</button>
    <button onclick="addPlanet();" id='add_planet_button'>Add Epicycle</button>
    <button onclick="removePlanet();" id='remove_planet_button'>Remove Epicycle</button>

</body>

